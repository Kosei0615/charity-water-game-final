// Log a message to the console to ensure the script is linked correctly
console.log('JavaScript file is linked correctly.');

// Page navigation
let currentPage = 'register-page';

function showPage(pageId) {
    // Start fade out animation for current page
    const currentPageElement = document.querySelector('.page.active');
    if (currentPageElement) {
        currentPageElement.style.opacity = '0';
        currentPageElement.style.transform = 'translateY(-20px)';
    }
    
    // Wait for fade out, then switch pages
    setTimeout(() => {
        // Hide all pages
        document.querySelectorAll('.page').forEach(page => {
            page.classList.remove('active');
            page.style.opacity = '0';
            page.style.transform = 'translateY(20px)';
        });
        
        // Show target page
        const targetPage = document.getElementById(pageId);
        if (targetPage) {
            targetPage.classList.add('active');
            currentPage = pageId;
            
            // Trigger reflow to ensure transition works
            targetPage.offsetHeight;
            
            // Fade in new page
            setTimeout(() => {
                targetPage.style.opacity = '1';
                targetPage.style.transform = 'translateY(0)';
            }, 50);
        }
    }, 200);
}

// Difficulty system
let currentDifficulty = 'easy';
const difficultySettings = {
    easy: {
        clearFlowTarget: 512,
        puzzleLevels: 3,
        name: 'Easy Mode',
        color: '#4FCB53'
    },
    normal: {
        clearFlowTarget: 1024,
        puzzleLevels: 4,
        name: 'Normal Mode',
        color: '#2E9DF7'
    },
    hard: {
        clearFlowTarget: 2048,
        puzzleLevels: 5,
        name: 'Hard Mode',
        color: '#F5402C'
    }
};

// Milestone tracking system - reduced messages
const milestones = {
    clearFlow: [
        { score: 512, message: "üåü Easy mode completed!" },
        { score: 1024, message: "üèÜ Normal mode completed!" },
        { score: 2048, message: "üéØ Hard mode completed!" }
    ],
    puzzlePipeline: [
        { level: 3, message: "üîß Easy levels completed!" },
        { level: 4, message: "üåä Normal levels completed!" },
        { level: 5, message: "‚ö° Hard levels completed!" }
    ]
};

// Track shown milestones to avoid repetition
let shownMilestones = {
    clearFlow: [],
    puzzlePipeline: []
};

// DOM manipulation effects
const domEffects = {
    createWaterDrops: function(count = 5) {
        for (let i = 0; i < count; i++) {
            const drop = document.createElement('div');
            drop.className = 'water-drop-effect';
            drop.innerHTML = 'üíß';
            drop.style.cssText = `
                position: fixed;
                font-size: 2rem;
                pointer-events: none;
                z-index: 1000;
                left: ${Math.random() * window.innerWidth}px;
                top: -50px;
                animation: dropFall 3s ease-in forwards;
            `;
            document.body.appendChild(drop);
            
            setTimeout(() => {
                if (drop.parentNode) {
                    drop.parentNode.removeChild(drop);
                }
            }, 3000);
        }
    },
    
    createCelebration: function() {
        const particles = ['üéâ', 'üåü', 'üí´', '‚ú®', 'üéä'];
        for (let i = 0; i < 15; i++) {
            const particle = document.createElement('div');
            particle.className = 'celebration-particle';
            particle.innerHTML = particles[Math.floor(Math.random() * particles.length)];
            particle.style.cssText = `
                position: fixed;
                font-size: 1.5rem;
                pointer-events: none;
                z-index: 1000;
                left: ${Math.random() * window.innerWidth}px;
                top: ${Math.random() * window.innerHeight}px;
                animation: celebrationPop 2s ease-out forwards;
            `;
            document.body.appendChild(particle);
            
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
            }, 2000);
        }
    },
    
    showMilestone: function(message) {
        const milestone = document.createElement('div');
        milestone.className = 'milestone-popup';
        milestone.innerHTML = message;
        milestone.style.cssText = `
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #FFC907 0%, #2E9DF7 100%);
            color: white;
            padding: 1rem 2rem;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(46,157,247,0.3);
            animation: milestoneAppear 3s ease-out forwards;
        `;
        document.body.appendChild(milestone);
        
        setTimeout(() => {
            if (milestone.parentNode) {
                milestone.parentNode.removeChild(milestone);
            }
        }, 3000);
    }
};

// Track progress in localStorage
const progress = {
    clearFlow: localStorage.getItem('cw_clearFlow') === 'done',
    puzzlePipeline: localStorage.getItem('cw_puzzlePipeline') === 'done'
};

// Initialize progress tracking
function initializeProgress() {
    const waterFill = document.getElementById('water-fill');
    const progressText = document.getElementById('progress-text');
    
    if (waterFill && progressText) {
        updateProgress();
    }
}

// Simple sound system for game feedback
const sounds = {
    move: () => playBeep(220, 100),
    merge: () => playBeep(440, 200),
    win: () => playBeep(880, 500),
    click: () => playBeep(330, 80),
    connect: () => playBeep(550, 150),
    complete: () => playBeep(660, 300)
};

// Helper function to create beep sounds
function playBeep(frequency, duration) {
    try {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = 'sine';
        
        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
        
        oscillator.start(audioContext.currentTime);
        oscillator.stop(audioContext.currentTime + duration / 1000);
    } catch (e) {
        console.log('Audio not supported');
    }
}

// Difficulty selection functionality
document.addEventListener('DOMContentLoaded', () => {
    // Initialize page system first
    initializePageSystem();
    
    // Initialize form handlers (only once)
    initializeFormHandlers();
    
    // Initialize difficulty system
    setTimeout(() => {
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        if (difficultyButtons.length > 0) {
            difficultyButtons.forEach(button => {
                button.addEventListener('click', () => {
                    difficultyButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    currentDifficulty = button.dataset.difficulty;
                    localStorage.setItem('cw_difficulty', currentDifficulty);
                    
                    sounds.click();
                    domEffects.createWaterDrops(2);
                    updateDifficultyDisplay();
                });
            });
            
            const savedDifficulty = localStorage.getItem('cw_difficulty');
            if (savedDifficulty && difficultySettings[savedDifficulty]) {
                currentDifficulty = savedDifficulty;
                difficultyButtons.forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.difficulty === currentDifficulty);
                });
            }
            
            updateDifficultyDisplay();
        }
    }, 100);
});

// Initialize page system
function initializePageSystem() {
    // Always start with register page unless player is already registered
    const savedName = localStorage.getItem('cw_player_name');
    const savedEmail = localStorage.getItem('cw_player_email');
    
    if (savedName && savedEmail) {
        // Player is already registered, go to hub
        showPage('hub-page');
    } else {
        // Show registration page
        showPage('register-page');
    }
}

// Initialize form handlers (separate from page system to prevent duplicate listeners)
function initializeFormHandlers() {
    // Player form submission
    const playerForm = document.getElementById('player-form');
    if (playerForm) {
        // Remove any existing listeners first
        const newForm = playerForm.cloneNode(true);
        playerForm.parentNode.replaceChild(newForm, playerForm);
        
        // Add error message containers if they don't exist
        const nameField = newForm.querySelector('#player-name');
        const emailField = newForm.querySelector('#player-email');
        
        if (!nameField.nextElementSibling || !nameField.nextElementSibling.classList.contains('form-error-message')) {
            const nameError = document.createElement('div');
            nameError.className = 'form-error-message';
            nameField.parentNode.insertBefore(nameError, nameField.nextSibling);
        }
        
        if (!emailField.nextElementSibling || !emailField.nextElementSibling.classList.contains('form-error-message')) {
            const emailError = document.createElement('div');
            emailError.className = 'form-error-message';
            emailField.parentNode.insertBefore(emailError, emailField.nextSibling);
        }
        
        // Real-time validation
        nameField.addEventListener('input', validateName);
        emailField.addEventListener('input', validateEmail);
        nameField.addEventListener('blur', validateName);
        emailField.addEventListener('blur', validateEmail);
        
        newForm.addEventListener('submit', (e) => {
            e.preventDefault();
            
            const submitBtn = newForm.querySelector('button[type="submit"]');
            const originalText = submitBtn.textContent;
            
            // Validate all fields
            const isNameValid = validateName();
            const isEmailValid = validateEmail();
            
            if (!isNameValid || !isEmailValid) {
                // Shake animation for invalid form
                newForm.style.animation = 'shake 0.6s ease-in-out';
                setTimeout(() => {
                    newForm.style.animation = '';
                }, 600);
                return;
            }
            
            // Add loading state
            submitBtn.textContent = 'Registering...';
            submitBtn.disabled = true;
            submitBtn.classList.add('loading');
            
            const name = nameField.value.trim();
            const email = emailField.value.trim();
            
            // Save to localStorage
            localStorage.setItem('cw_player_name', name);
            localStorage.setItem('cw_player_email', email);
            
            // Create welcome effect
            domEffects.createWaterDrops(3);
            sounds.click();
            
            // Smooth transition with delay
            setTimeout(() => {
                submitBtn.textContent = '‚úì Welcome!';
                submitBtn.style.background = 'linear-gradient(135deg, var(--accent-green), #4FCB53)';
                
                setTimeout(() => {
                    showPage('hub-page');
                    
                    // Reset form for future use
                    setTimeout(() => {
                        submitBtn.textContent = originalText;
                        submitBtn.disabled = false;
                        submitBtn.classList.remove('loading');
                        submitBtn.style.background = '';
                        nameField.value = '';
                        emailField.value = '';
                        nameField.classList.remove('success', 'error');
                        emailField.classList.remove('success', 'error');
                    }, 1000);
                }, 800);
            }, 600);
        });
    }
    
    // Validation functions
    function validateName() {
        const nameField = document.getElementById('player-name');
        const nameError = nameField.nextElementSibling;
        const name = nameField.value.trim();
        
        if (!name) {
            showFieldError(nameField, nameError, 'Name is required');
            return false;
        } else if (name.length < 2) {
            showFieldError(nameField, nameError, 'Name must be at least 2 characters');
            return false;
        } else {
            showFieldSuccess(nameField, nameError);
            return true;
        }
    }
    
    function validateEmail() {
        const emailField = document.getElementById('player-email');
        const emailError = emailField.nextElementSibling;
        const email = emailField.value.trim();
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        
        if (!email) {
            showFieldError(emailField, emailError, 'Email is required');
            return false;
        } else if (!emailRegex.test(email)) {
            showFieldError(emailField, emailError, 'Please enter a valid email address');
            return false;
        } else {
            showFieldSuccess(emailField, emailError);
            return true;
        }
    }
    
    function showFieldError(field, errorElement, message) {
        field.classList.remove('success');
        field.classList.add('error');
        if (errorElement) {
            errorElement.textContent = message;
            errorElement.classList.add('show');
        }
    }
    
    function showFieldSuccess(field, errorElement) {
        field.classList.remove('error');
        field.classList.add('success');
        if (errorElement) {
            errorElement.classList.remove('show');
        }
    }
    
    // Game navigation buttons
    const playButtons = {
        'play-clear-flow': () => {
            showPage('clear-flow-page');
            startClearFlowGame();
        },
        'play-puzzle-pipeline': () => {
            showPage('puzzle-pipeline-page');
            startPuzzlePipelineGame();
        }
    };
    
    Object.entries(playButtons).forEach(([buttonId, handler]) => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.addEventListener('click', handler);
        }
    });
    
    // Back buttons
    const backButtons = ['cf-back', 'pp-back'];
    backButtons.forEach(buttonId => {
        const button = document.getElementById(buttonId);
        if (button) {
            button.addEventListener('click', () => {
                showPage('hub-page');
            });
        }
    });
    
    // Initialize progress tracking
    initializeProgress();
}

// Update difficulty display
function updateDifficultyDisplay() {
    const settings = difficultySettings[currentDifficulty];
    const difficultyInfo = document.querySelector('.difficulty-section h3');
    if (difficultyInfo) {
        difficultyInfo.innerHTML = `Choose Your Difficulty - Current: <span style="color: ${settings.color}">${settings.name}</span>`;
    }
}

// Check and show milestones
function checkMilestones(gameType, value) {
    const milestonesForGame = milestones[gameType];
    if (!milestonesForGame) return;
    
    milestonesForGame.forEach(milestone => {
        const key = gameType === 'clearFlow' ? 'score' : 'level';
        const hasShown = shownMilestones[gameType].includes(milestone[key]);
        
        // Only trigger on exact match, not just >= 
        if (!hasShown && value === milestone[key]) {
            domEffects.showMilestone(milestone.message);
            domEffects.createCelebration();
            shownMilestones[gameType].push(milestone[key]);
        }
    });
}

// Show main menu
function showMainMenu() {
    showPage('hub-page');
    updateProgress();
}

// Show celebration screen
function showCelebration() {
    sounds.complete();
    showPage('hub-page');
    
    // Show celebration overlay
    const celebrationOverlay = document.createElement('div');
    celebrationOverlay.className = 'celebration-overlay';
    celebrationOverlay.innerHTML = `
        <div class="celebration-content">
            <h1>üéâ Congratulations! üéâ</h1>
            <h2>You've successfully cleaned the water tank!</h2>
            <p>Thank you for helping charity: water's mission!</p>
            <button class="main-btn" onclick="this.parentElement.parentElement.remove()">Continue</button>
        </div>
    `;
    
    celebrationOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    `;
    
    celebrationOverlay.querySelector('.celebration-content').style.cssText = `
        background: linear-gradient(135deg, #2E9DF7, #FFC907);
        color: white;
        padding: 3rem;
        border-radius: 20px;
        text-align: center;
        max-width: 500px;
        margin: 1rem;
    `;
    
    document.body.appendChild(celebrationOverlay);
    
    updateProgress();
}

// Update progress
function updateProgress() {
    const waterFill = document.getElementById('water-fill');
    const progressText = document.getElementById('progress-text');
    
    if (!waterFill || !progressText) return;
    
    const completedGames = Object.values(progress).filter(Boolean).length;
    const totalGames = Object.keys(progress).length;
    const percentage = (completedGames / totalGames) * 100;
    
    waterFill.style.height = percentage + '%';
    progressText.textContent = `Progress: ${completedGames}/${totalGames} games completed`;
    
    if (completedGames === totalGames) {
        showCelebration();
    }
}

// Mark games as complete
function markClearFlowComplete() {
    localStorage.setItem('cw_clearFlow', 'done');
    progress.clearFlow = true;
    updateProgress();
}

function markPuzzlePipelineComplete() {
    localStorage.setItem('cw_puzzlePipeline', 'done');
    progress.puzzlePipeline = true;
    updateProgress();
}

// Clear the Flow Game (2048-style) - removed old inline HTML version

function startClearFlowGame() {
    // Reset milestones for this game session
    shownMilestones.clearFlow = [];
    
    // Update UI elements
    document.getElementById('cf-difficulty').textContent = difficultySettings[currentDifficulty].name;
    document.getElementById('cf-target').textContent = difficultySettings[currentDifficulty].clearFlowTarget;
    
    // 4x4 grid, filled with 0 (empty)
    let board = [
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0],
        [0,0,0,0]
    ];
    let score = 0;
    let gameOver = false;
    const boardDiv = document.getElementById('cf-board');
    const scoreDiv = document.getElementById('cf-score');
    const messageDiv = document.getElementById('cf-message');

    // Add two starting tiles
    addRandomTile();
    addRandomTile();
    updateBoard();
    messageDiv.style.display = 'none';

    // Listen for arrow keys
    document.addEventListener('keydown', handleKey);
    
    // Reset button
    document.getElementById('cf-reset').onclick = () => {
        board = [
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0],
            [0,0,0,0]
        ];
        score = 0;
        gameOver = false;
        addRandomTile();
        addRandomTile();
        updateBoard();
        messageDiv.style.display = 'none';
        document.addEventListener('keydown', handleKey);
    };

    function addRandomTile() {
        const empty = [];
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                if (board[r][c] === 0) empty.push([r, c]);
            }
        }
        if (empty.length > 0) {
            const [r, c] = empty[Math.floor(Math.random() * empty.length)];
            board[r][c] = Math.random() < 0.9 ? 2 : 4;
        }
    }

    function updateBoard() {
        scoreDiv.textContent = score;
        boardDiv.innerHTML = '';
        
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                const tile = document.createElement('div');
                tile.className = 'cf-cell';
                tile.textContent = board[r][c] === 0 ? '' : board[r][c];
                tile.setAttribute('data-value', board[r][c]);
                
                // Add special styling for target tile
                if (board[r][c] === difficultySettings[currentDifficulty].clearFlowTarget) {
                    tile.style.border = '3px solid #FFC907';
                    tile.style.boxShadow = '0 0 20px rgba(255,201,7,0.5)';
                }
                
                boardDiv.appendChild(tile);
            }
        }
    }

    function handleKey(e) {
        if (gameOver) return;
        
        let moved = false;
        const oldScore = score;
        
        if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown"].includes(e.key)) {
            e.preventDefault();
            const oldBoard = JSON.stringify(board);
            
            if (e.key === "ArrowLeft") moveLeft();
            if (e.key === "ArrowRight") moveRight();
            if (e.key === "ArrowUp") moveUp();
            if (e.key === "ArrowDown") moveDown();
            
            if (JSON.stringify(board) !== oldBoard) moved = true;
        }
        
        if (moved) {
            sounds.move();
            if (score > oldScore) {
                sounds.merge();
            }
            addRandomTile();
            updateBoard();
            checkGameOver();
        }
    }

    function moveLeft() {
        for (let r = 0; r < 4; r++) {
            let row = board[r].filter(x => x);
            for (let c = 0; c < row.length - 1; c++) {
                if (row[c] === row[c + 1]) {
                    row[c] *= 2;
                    score += row[c];
                    row[c + 1] = 0;
                }
            }
            row = row.filter(x => x);
            while (row.length < 4) row.push(0);
            board[r] = row;
        }
    }

    function moveRight() {
        for (let r = 0; r < 4; r++) {
            let row = board[r].filter(x => x);
            for (let c = row.length - 1; c > 0; c--) {
                if (row[c] === row[c - 1]) {
                    row[c] *= 2;
                    score += row[c];
                    row[c - 1] = 0;
                }
            }
            row = row.filter(x => x);
            while (row.length < 4) row.unshift(0);
            board[r] = row;
        }
    }

    function moveUp() {
        for (let c = 0; c < 4; c++) {
            let col = [];
            for (let r = 0; r < 4; r++) col.push(board[r][c]);
            col = col.filter(x => x);
            for (let r = 0; r < col.length - 1; r++) {
                if (col[r] === col[r + 1]) {
                    col[r] *= 2;
                    score += col[r];
                    col[r + 1] = 0;
                }
            }
            col = col.filter(x => x);
            while (col.length < 4) col.push(0);
            for (let r = 0; r < 4; r++) board[r][c] = col[r];
        }
    }

    function moveDown() {
        for (let c = 0; c < 4; c++) {
            let col = [];
            for (let r = 0; r < 4; r++) col.push(board[r][c]);
            col = col.filter(x => x);
            for (let r = col.length - 1; r > 0; r--) {
                if (col[r] === col[r - 1]) {
                    col[r] *= 2;
                    score += col[r];
                    col[r - 1] = 0;
                }
            }
            col = col.filter(x => x);
            while (col.length < 4) col.unshift(0);
            for (let r = 0; r < 4; r++) board[r][c] = col[r];
        }
    }

    function checkGameOver() {
        const winTarget = difficultySettings[currentDifficulty].clearFlowTarget;
        
        // Check for win
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                if (board[r][c] === winTarget) {
                    sounds.win();
                    domEffects.createCelebration();
                    const difficultyName = difficultySettings[currentDifficulty].name.replace(' Mode', '');
                    messageDiv.innerHTML = `üéâ Congratulations! You cleared ${difficultyName} difficulty!<br>Returning to main hub...`;
                    messageDiv.className = 'game-message success';
                    messageDiv.style.display = 'block';
                    document.removeEventListener('keydown', handleKey);
                    markClearFlowComplete();
                    gameOver = true;
                    
                    // Trigger milestone only on actual completion
                    checkMilestones('clearFlow', winTarget);
                    
                    // Auto return to hub after 3 seconds
                    setTimeout(() => {
                        showPage('hub-page');
                    }, 3000);
                    return;
                }
            }
        }
        
        // Check for game over
        if (!canMove()) {
            messageDiv.innerHTML = 'No more moves! Try again.';
            messageDiv.className = 'game-message info';
            messageDiv.style.display = 'block';
            document.removeEventListener('keydown', handleKey);
            gameOver = true;
        }
    }

    function canMove() {
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                if (board[r][c] === 0) return true;
                if (c < 3 && board[r][c] === board[r][c + 1]) return true;
                if (r < 3 && board[r][c] === board[r + 1][c]) return true;
            }
        }
        return false;
    }
}

// Puzzle Pipeline Game (Number linking game) - removed old inline HTML version

function startPuzzlePipelineGame() {
    let currentLevel = 0;
    const maxLevels = difficultySettings[currentDifficulty].puzzleLevels;
    let isDrawing = false;
    
    // Reset milestones for this game session
    shownMilestones.puzzlePipeline = [];
    
    // Update UI
    document.getElementById('pp-difficulty').textContent = difficultySettings[currentDifficulty].name;
    
    const levels = [
        {
            grid: [
                [1, 0, 0, 2],
                [0, 0, 0, 0],
                [0, 0, 0, 0],
                [1, 0, 0, 2]
            ],
            size: 4
        },
        {
            grid: [
                [1, 0, 0, 0],
                [0, 0, 2, 0],
                [0, 3, 1, 0],
                [2, 0, 0, 3]
            ],
            size: 4
        },
        {
            grid: [
                [1, 3, 0, 0, 0],
                [0, 0, 2, 0, 0],
                [0, 0, 1, 0, 0],
                [0, 0, 0, 0, 0],
                [2, 0, 0, 0, 3]
            ],
            size: 5
        },
        {
            grid: [
                [1, 0, 0, 2, 3],
                [0, 2, 3, 0, 0],
                [0, 0, 4, 0, 0],
                [5, 0, 0, 0, 0],
                [0, 0, 5, 1, 4]
            ],
            size: 5
        },
        {
            grid: [
                [1, 0, 0, 2, 0, 0],
                [0, 0, 0, 0, 0, 0],
                [0, 3, 0, 0, 4, 0],
                [0, 1, 0, 0, 0, 0],
                [0, 4, 2, 0, 0, 0],
                [3, 0, 0, 0, 0, 0]
            ],
            size: 6
        }
    ];

    function loadLevel(levelIndex) {
        if (levelIndex >= maxLevels) {
            // All levels completed
            sounds.complete();
            domEffects.createCelebration();
            const messageDiv = document.getElementById('pp-message');
            messageDiv.innerHTML = `üéâ All levels completed on ${difficultySettings[currentDifficulty].name}!`;
            messageDiv.className = 'game-message success';
            messageDiv.style.display = 'block';
            markPuzzlePipelineComplete();
            
            // Auto return to hub after 3 seconds
            setTimeout(() => {
                showPage('hub-page');
            }, 3000);
            return;
        }

        // Update level display
        document.getElementById('pp-level').textContent = levelIndex + 1;
        
        const level = levels[levelIndex];
        const size = level.size;
        const grid = [...level.grid.map(row => [...row])]; // Deep copy
        
        // Find endpoints
        const endpoints = {};
        for (let r = 0; r < size; r++) {
            for (let c = 0; c < size; c++) {
                if (grid[r][c] > 0) {
                    const num = grid[r][c];
                    if (!endpoints[num]) endpoints[num] = [];
                    endpoints[num].push([r, c]);
                }
            }
        }

        let paths = {};
        let currentPath = null;
        let solved = false;

        const boardDiv = document.getElementById('pp-board');
        const levelDiv = document.getElementById('pp-level');
        const messageDiv = document.getElementById('pp-message');
        
        levelDiv.textContent = `Level ${levelIndex + 1}`;
        boardDiv.style.gridTemplateColumns = `repeat(${size}, 70px)`;
        boardDiv.style.gridTemplateRows = `repeat(${size}, 70px)`;
        
        drawBoard();

        function drawBoard() {
            boardDiv.innerHTML = '';
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'pp-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    if (grid[r][c] > 0) {
                        cell.textContent = grid[r][c];
                        cell.classList.add('pp-endpoint');
                        cell.style.backgroundColor = getColor(grid[r][c]);
                        cell.style.color = '#fff';
                        cell.style.fontWeight = 'bold';
                    } else {
                        // Check if this cell is part of a completed path
                        let inPath = false;
                        for (let num in paths) {
                            if (paths[num].some(([pr, pc]) => pr === r && pc === c)) {
                                cell.style.backgroundColor = getColor(num);
                                cell.classList.add('pp-path');
                                inPath = true;
                                break;
                            }
                        }
                        
                        // Check if this cell is part of the current path being drawn
                        if (!inPath && currentPath && currentPath.path.some(([pr, pc]) => pr === r && pc === c)) {
                            cell.style.backgroundColor = getColor(currentPath.number);
                            cell.style.opacity = '0.7';
                            cell.classList.add('pp-current-path');
                            inPath = true;
                        }
                        
                        if (!inPath) {
                            cell.textContent = '';
                            cell.style.backgroundColor = '';
                            cell.style.opacity = '';
                            cell.classList.remove('pp-path', 'pp-current-path');
                        }
                    }
                    
                    cell.addEventListener('mousedown', startPath);
                    cell.addEventListener('mouseenter', continuePath);
                    cell.addEventListener('mouseup', endPath);
                    
                    // Touch events for mobile
                    cell.addEventListener('touchstart', startPath);
                    cell.addEventListener('touchmove', handleTouchMove);
                    cell.addEventListener('touchend', endPath);
                    
                    boardDiv.appendChild(cell);
                }
            }
            
            // Global mouse up to stop drawing when mouse leaves the board
            document.addEventListener('mouseup', () => {
                if (isDrawing) {
                    isDrawing = false;
                    currentPath = null;
                    drawBoard();
                }
            });
        }

        function startPath(e) {
            if (solved) return;
            e.preventDefault();
            
            const r = parseInt(e.target.dataset.row);
            const c = parseInt(e.target.dataset.col);
            
            if (grid[r][c] > 0) {
                const num = grid[r][c];
                currentPath = { number: num, path: [[r, c]] };
                isDrawing = true;
                sounds.click();
                drawBoard(); // Redraw to show current path
            }
        }

        function continuePath(e) {
            if (!currentPath || solved || !isDrawing) return;
            e.preventDefault();
            
            const r = parseInt(e.target.dataset.row);
            const c = parseInt(e.target.dataset.col);
            
            // Check if this is a valid next cell
            const lastPos = currentPath.path[currentPath.path.length - 1];
            const distance = Math.abs(r - lastPos[0]) + Math.abs(c - lastPos[1]);
            
            if (distance === 1) { // Adjacent cell
                if (grid[r][c] === 0 || grid[r][c] === currentPath.number) {
                    // Check if not already in current path
                    if (!currentPath.path.some(([pr, pc]) => pr === r && pc === c)) {
                        currentPath.path.push([r, c]);
                        sounds.connect();
                        drawBoard(); // Redraw to show updated path
                    }
                }
            }
        }

        function handleTouchMove(e) {
            if (!currentPath || solved || !isDrawing) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (element && element.dataset && element.dataset.row !== undefined) {
                const r = parseInt(element.dataset.row);
                const c = parseInt(element.dataset.col);
                
                // Check if this is a valid next cell
                const lastPos = currentPath.path[currentPath.path.length - 1];
                const distance = Math.abs(r - lastPos[0]) + Math.abs(c - lastPos[1]);
                
                if (distance === 1) { // Adjacent cell
                    if (grid[r][c] === 0 || grid[r][c] === currentPath.number) {
                        // Check if not already in current path
                        if (!currentPath.path.some(([pr, pc]) => pr === r && pc === c)) {
                            currentPath.path.push([r, c]);
                            sounds.connect();
                            drawBoard(); // Redraw to show updated path
                        }
                    }
                }
            }
        }

        function endPath(e) {
            if (!currentPath || solved) return;
            e.preventDefault();
            isDrawing = false;
            
            const r = parseInt(e.target.dataset.row);
            const c = parseInt(e.target.dataset.col);
            
            // Check if we ended at the matching endpoint
            if (grid[r][c] === currentPath.number && currentPath.path.length > 1) {
                const endpointPairs = endpoints[currentPath.number];
                if (endpointPairs.length === 2) {
                    const [start, end] = endpointPairs;
                    const pathStart = currentPath.path[0];
                    const pathEnd = currentPath.path[currentPath.path.length - 1];
                    
                    if ((pathStart[0] === start[0] && pathStart[1] === start[1] && 
                         pathEnd[0] === end[0] && pathEnd[1] === end[1]) ||
                        (pathStart[0] === end[0] && pathStart[1] === end[1] && 
                         pathEnd[0] === start[0] && pathEnd[1] === start[1])) {
                        
                        paths[currentPath.number] = currentPath.path;
                        sounds.complete();
                        // Removed checkMilestones here - only check on full level completion
                    }
                    }
                }
            }
            
            currentPath = null;
            drawBoard();
            checkWin();
        }

        function checkWin() {
            // Check if all cells are filled
            let filledCells = 0;
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (grid[r][c] > 0) {
                        filledCells++;
                    } else {
                        // Check if part of a path
                        for (let num in paths) {
                            if (paths[num].some(([pr, pc]) => pr === r && pc === c)) {
                                filledCells++;
                                break;
                            }
                        }
                    }
                }
            }
            
            if (filledCells === size * size && Object.keys(paths).length === Object.keys(endpoints).length) {
                solved = true;
                sounds.win();
                
                // Check milestones only on complete level finish
                if (levelIndex + 1 === maxLevels) {
                    checkMilestones('puzzlePipeline', maxLevels);
                }
                
                if (levelIndex === maxLevels - 1) {
                    // All levels completed
                    const messageDiv = document.getElementById('pp-message');
                    messageDiv.innerHTML = `üéâ Congratulations! You cleared Puzzle Pipeline!<br>Returning to main hub...`;
                    messageDiv.className = 'game-message success';
                    messageDiv.style.display = 'block';
                    
                    setTimeout(() => {
                        markPuzzlePipelineComplete();
                        showPage('hub-page');
                    }, 3000);
                } else {
                    // Level completed, show message and auto-advance to next level
                    const messageDiv = document.getElementById('pp-message');
                    messageDiv.innerHTML = `üíß Level ${levelIndex + 1} complete! Moving to level ${levelIndex + 2}...`;
                    messageDiv.className = 'game-message success';
                    messageDiv.style.display = 'block';
                    
                    // Increment currentLevel and load the next level
                    currentLevel = levelIndex + 1;
                    setTimeout(() => {
                        messageDiv.style.display = 'none';
                        loadLevel(currentLevel);
                    }, 1500);
                }
            }
        }

        function getColor(num) {
            const colors = ['#2E9DF7', '#FFC907', '#4FCB53', '#F5402C', '#8BD1CB', '#FF902A'];
            return colors[(num - 1) % colors.length];
        }

        // Reset button
        document.getElementById('pp-reset').onclick = () => {
            paths = {};
            currentPath = null;
            solved = false;
            isDrawing = false;
            drawBoard();
            const messageDiv = document.getElementById('pp-message');
            messageDiv.style.display = 'none';
            sounds.click();
        };
    }

    loadLevel(currentLevel);
}

// Add logout function for testing
function clearRegistration() {
    localStorage.removeItem('cw_player_name');
    localStorage.removeItem('cw_player_email');
    showPage('register-page');
}

// Add this to window for testing in console
window.clearRegistration = clearRegistration;
